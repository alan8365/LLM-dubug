{
    "sample": {
        "prog_id": 13,
        "prog_name": "knapsack",
        "language": "python",
        "testcase_num": 9,
        "fault_location": 10,
        "bug_type": "",
        "bug_detail_desc": "在寫動態規劃的陣列時，沒有考慮到weight剛好等於容納上限的狀況，導致該類邊緣狀況輸出錯誤答案"
    },
    "patchs_eval": [
        {
            "run_time": 7.36173415184021,
            "pass_num": 9,
            "fail_num": 0,
            "reparied_code": "\ndef knapsack(capacity, items):\n    from collections import defaultdict\n    memo = defaultdict(int)\n\n    for i in range(1, len(items) + 1):\n        weight, value = items[i - 1]\n\n        for j in range(1, capacity + 1):\n            memo[i, j] = memo[i - 1, j]\n\n            if weight <= j:  # weight can equal to j so use <= instead of <\n                memo[i, j] = max(\n                    memo[i, j],\n                    value + memo[i - 1, j - weight]\n                )\n\n    return memo[len(items), capacity]"
        },
        {
            "run_time": 5.886023759841919,
            "pass_num": 9,
            "fail_num": 0,
            "reparied_code": "\ndef knapsack(capacity, items):\n    from collections import defaultdict\n    memo = defaultdict(int)\n\n    for i in range(1, len(items) + 1):\n        weight, value = items[i - 1]\n\n        for j in range(1, capacity + 1):\n            memo[i, j] = memo[i - 1, j]\n\n            if weight <= j:  # weight can be equal to j, not only less than j\n                memo[i, j] = max(\n                    memo[i, j],\n                    value + memo[i - 1, j - weight]\n                )\n\n    return memo[len(items), capacity]"
        },
        {
            "run_time": 5.7735350131988525,
            "pass_num": 9,
            "fail_num": 0,
            "reparied_code": "\n\ndef knapsack(capacity, items):\n    from collections import defaultdict\n    memo = defaultdict(int)\n\n    for i in range(1, len(items) + 1):\n        weight, value = items[i - 1]\n\n        for j in range(1, capacity + 1):\n            memo[i, j] = memo[i - 1, j]\n\n            if weight <= j:\n                memo[i, j] = max(\n                    memo[i, j],\n                    value + memo[i - 1, j - weight]\n                )\n\n    return memo[len(items), capacity]\n"
        }
    ]
}